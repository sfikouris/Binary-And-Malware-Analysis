* Nickname : CU 
* First I patch entry point with NOP because it wasn’t at the correct addr.
* Anti-debugging techniques : self debugging ->ptrace. To solve this I patched at 0010024c the mov instruction to MOV EAX,0x0 
* Anti-VM techniques : look for VM-specific virtual hardware : After FUN_00100322 finished (looking at sys_Vendor, board_vendor, bios_vendor, chassis_vendor) It wants to match with the NukeOs but unfortunately on my pc I have only Linux :P. So I changed the instruction at 00100d7d from STNZ AL to MOV AL,0 because the function returns not 0 (no Matches) $EAX has a value != 0 . So TEST $EAX,$EAX != 0 , hence STNZ AL it will take value = 1. So I go and manually put the 0 in AL.
* Next FUN_00100322 It’s called again but now it checks for VM-name (for example “QEMU”). This Function has a hit if you run it on a VM so I Patched the instruction at  00100db6   to MOV BL,0x0. Here the function is compare in vm-names and it will return 0 because if you run it in avm you will have a match so $EAX value is equal to 0. TEST $EAX,$EAX it’s going to be 0 So SETZ BL it's going to set BL to 1. That's why i did it manually to 0.
* At 0010139a there is CPUID this could be use for Anti-Vm but I did nothing with it :) 
* Also Function FUN_00100256 calls syscall time. (it counts as anti-debugging technique in general but here i think does nothing).
* Binary is checking for authorization in 2 steps. a) scan the environment variables of the system with getenv() to find out if the key word “ARMING_KEY” is in there. b) If it finds, it checks the value in ARMING_KEY variable to see if it matches the string that is at addr 00100b0b. So from there I can see that the password is ‘WJTMBJPMPOTBZEBWBXYT’. Now you have to export ARMING_KEY=WJTMBJPMPOTBZEBWBXYT so you will pass the authorization and start the arming code calculator.
