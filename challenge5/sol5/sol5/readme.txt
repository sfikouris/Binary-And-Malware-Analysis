
1. Determine conditions for valid words & find one word/marklar pair
    With the help of Ghidra I found the dictionary of marklar word "@ABCDEFHJKLMNPQRTUVWXYZ*~^&/:,;-"
    Also we can find with Ghidra disassembly the length that word must be 0x10. 

    To find a word with meaning we need this function FUN_004011d0(local_68,0x54) to return 0. But first we see that when the function returns
	only the lower 8-bits of eax are compared with 0 so we don't need the whole register to be 0. The local_68 parameter it is actually our input word in internal
representation. It is an array of every character's offset in the dictionary.(for example character A has offset 00001). 

FUN_004011d0 takes that array and XOR every byte with 0xAA for even and 0x55 for odd and the sum of all 80 bits + 0x54 (second parameter of FUN_004011d0) should return a number that the lower byte is 0 so the word is valid and with meaning in a MARKLAR.      



2. Use symbex to gather the constraints that need to apply
for a word to have meaning.
    For this part first I run through symbex function_4011d0 and my symbolic variable as a parameter. My symbolic variable has length 640 bits 
    because as in internal representation every bit is represented with a byte. Next step I had to add constraints to the symbolic variable so that every byte of the variable should be neither 1 or 0 to be the same as memory representation . 
    Then I run the symbex through the loop as the executable does. I explore to a every branch and merge the states every time because otherwise it takes too long  
    or even gets a state explosion. After, at the time of return I add the constraint that al registre must be 0 so it can be counted as a word with meaning.

3. Find and capture the marklar assignment algorithm
    Now we have to search in function_4046d0 and pass also the previous symbolic variable and one more for the marklar. Because it is a new state
    we have to pass the constraints from earlier symbex execution to have a valid and meaningful word. Again as before, pass constraints to the new symbolic variable so that every byte of the variable should be 1 or 0 to match the memory representation. 
    Next we let it go through the 56 functions that generate marklar. Every function is responsible for the value of every bit in marklar. After the indirect call we add the constraints for each bit in marklar to state. 
    Lastly we explore to the return' address and there we have captured the MARKLAR algorithm's SMTs.

4. Solve gathered constraints and obtain all possible marklars
    We are at the state that we finished from marklar function assignment. From there we have both algorithms SMTs and we are able to evaluate our symbolic variables.
There I run a loop as long as the state is satisfiable and I evaluate the marklar word pairs.
    Because our variables are 640 and 448 bits, to translate them to words and marklar first we have to do some magic (see script :D ).

To run the script. chmod +x script.sh. It needs around 7 min to run and then it's going to produce marklar.out 
    

