I have created 3 files for static patching, dynamic pathing and do get the hidden manual.
You can find dynamic patching and hidden manual scripts at dynamic_script folder. Static patching is in the script_static folder.
Just  make them executable and they should run.


Task 1a: 
	to find call obfuscation first I printed out all the call instructions.
	Then I found out that some calls are indirect (call rbx). Then I hook only the indirect calls.
	After that I noticed that some indirect calls before got call the register took some arithmetic operation 
	and more specific ADD. I shrink my obfuscation call list with this addition. After I had my final list,
	I should check if the indirect calls jump always to the same address. If yes then this specific call 
	saved as obfuscation and I should patch it. To do the patch I read that the call instruction should take as argument 
	the difference between (function address) - (next instruction address after call), and with this way I get the 
	actual bytes to call the function. Then I write in a file (call_file.txt) the address where to begin the call instruction 
	(is the address of ADD instruction because I need 5 bytes to write down the instruction). Then I write the actual bytes of the instruction.
	After I give this file to my patch_call.py script to go and patch the 5 bytes and also it patches 4 NOPs to fill the gap.


Task 1a:
	 to do the dynamic ret patching: First  I find calls and push the address of next instruction in a stack 
	( the call address should not be in the plt section because there are library functions and we don't care about them).
	I used stack for calls next instruction because every time I found RETURN the return value should be the same with the next instruction 
	of call if it's not an obfuscation. Then every time I find a return instruction I check if this return instruction 
	it's outside of the .plt section and also check if the value of ret is equal to the top address in my stack. IF it's NOT equal then this is 
	an obfuscation. I write in a file (temp.txt) the expecting ret address and also the actual ret address. Then I sort this file to have only 
	unique values and i give it to patch_call.py script to do the patching. The patch processing it's easy here. I found the difference 
	between (actual ret address) -(expecting ret address) and then I start patching NOPs from expecting ret address until the difference.


Task 1b:
    static call patch : First I went to Ghidra and found out how the rbx value was born. we can easy find the constant that add to rbx but 
    we still don't know the rbx value. So with the help of GDB I found that the rbx value before the ADD instruction is a constant value
    and it's the same every time. Next step, we can see from Ghidra that the bytes of CALL RBX are always the same. So I start trucking 
    all the bytes with sequence "\xff\xd3". every time I get on those bytes, I'm checking the bytes of previous instruction if they are
    the same as our ADD instruction ( \x48\x81\xc3 ). If I had a match I know for sure that this is the call obfuscation. I continue read 
    ADD instruction bytes and I can find the constant value and with the rbx value that already know from GDB I can create the actual rbx
    value that calls the function. I also know that the call that I want to patch it's 5bytes again. I also know the address of ADD 
    instruction. So I moved 5 bytes form ADD instruction and I can find the expected ret address. If I subtract rbx value - expecting ret
    I have the bytes for my function. Then I create the exact same file (static_call.txt) as taska1 dynamic call patching and give it 
    to patch_call.py to do the patching.


    static ret patch : Again I went to Ghidra and more specific in a function that i knew from dynamic analysis that the return it's not 
    correct. So after some inspection i found that the rbp value get obfuscated with those bytes 
        48 8b 45 08     MOV RAX,qword ptr [RBP + local_res0]
        48 83 c0 07     ADD RAX,0x7.
        48 89 45 08     MOV qword ptr [RBP + local_res0],RAX

    As you can see I only care for the first 7 bytes to find if this ret val gets obfuscated because the 8 byte is the value that was added to RBP.
    Now I need to find which function is this. To find the address of the function I'm going to look for a specific instructions that get
    action every time after a function gets called.
        55       PUSH RBP
        48 89 e5 MOV RBP, RSP.
    The address of PUSH RBP is the beginning of function. Then I need to find who is the caller. I start trucking all direct calls (\e8).
    then I trap the 4 next bytes of the call instruction (with that way I had the function bytes). Then I add those bytes with the address
    of the next instruction, and if i have a match with the address of PUSH RBP I found the caller. Then I create a file (static_ret.txt) 
    with the expecting ret and actual ret ( to find actual i just add the 8th byte of the obfuscation sequence to expecting ret address).
    After that I gave this file to Patch_call.py as task 1a dynamic ret patching.


Task 2 : To recover second manual.
    step1 : went to Ghidra .data section. scroll down and at address 0x613680 until 0x0613e78 you can find the taintwashing functions.
    step2 : at run time with tainttool visit those addresses and save the bytes of those. Those bytes represent where the taintwashing 
        function address are.
    step3 : check every call that binary executes at run time. If the target address of call is the same as one of the addresses that we
        saved in step2 we have to save the next instruction address (expected return address) and also save the RDI taint status.
    step4 : Every time the binary executes return instruction we have to check if this return instruction match with the last expected ret
         address that we saved in step3. With this ways we can understand that the call that just return was a taintwashing function. Then
         we have to check the status of RDI that we saved again in setp3. If status is tainted we have to check the EAX taint value (EAX holds
         the return value of a function). If it's clear then we know for sure that RDI value pass through taintwashing function and we have to
         propagate the taint to EAX. If EAX has the taint, we have to clear it because it's obfuscation function.



